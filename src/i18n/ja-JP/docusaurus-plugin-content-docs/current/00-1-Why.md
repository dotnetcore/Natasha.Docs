---
title: "なぜナタシャが必要なのですか?"
sidebar_position: 2
---

## 知識の予備

これまでのところ、ダイナミックコンパイルとは何か、Emitがどのようなシナリオで使用するか、式ツリーがどのように使用されるのか、まだ理解していない学生は、[食の記事など、最初に学習するための資料を探](https://www.cnblogs.com/whuanle/category/1548012.html)。

## 現代的な柱

動的コンパイルは、現代の .NET エコロジーを支える重要な柱の 1 つであり、このテクノロジはさまざまな公式および非公式のライブラリに "サービス" されています。動的コンパイルの核となるのは MSIL で、IL コードの作成は Emit テクノロジを公式に提供しますが、Emit の記述と保守は苦痛であり、構文糖の復元、非同期メソッド、命令の互換性、大量のメタデータ操作、エラー デバッグ、動的オートマトン、複雑なビジネスの動的構築など、500 行の EmitCode の前では、ほとんどの人が 200 行のジャンプ ラベルの前で耳をつんざくなど、痛みを伴います。 このコストのかかる表現は、オープンソースプロジェクトの作者だけが知っているのかもしれない。

このことはとても重要なのに、なぜカプセル化しないのですか?公式には、比較的人間的な式ツリーが提供されていますが、これは単に書き込みの容易さを向上させるだけでなく、式ツリーに基づく構成や解析など、いくつかの新しいことを追加します。

## 解決への道

Roslyn の登場により、Emit を透明にし、C# コードを使用して動的にコンパイルできるエコロジーの希望が生まれています。これは王道、兄弟、これは新しい時代の大きな輝きです。このスキームは、鳥銃の銃の交換に当てはまではなく、一部の人々は、公式の態度を気にする可能性が高い、ここで言うことができる、公式は、あなたが管理することができる問題を扱うことができる場合を含め、この技術は、参照依存、エラー処理、サブドメインロードなどの問題を引き起こす。一連の調査、照合、テストの後、Natasha は 2019 年に一般向けに正式にリリースされ、現在 netcore/net5 リリースで安定版をリリースしており、この 2 年間は統合からデカップリング、中ルールから新しい技術アプリケーションまで、Natasha は> の> と> の洗練から> 光までの道を歩み始えています。次に、Natasha のアプリケーションを例にとり、詳しく説明します。

## プロジェクトの初見

Natasha は MIT オープンソース プロトコルを採用し、DotNetCore.Natasha.CSharp.All を参照することで Natasha を使用できる実戦テストを受けた。

Natasha の最も基本的なコンパイル単位は AssemblyCSharpBuilder で、多くのプロパティがあります。

- CompileErrorBehavior コンパイルエラーの動作。デフォルトでは例外がスローされます。
- SyntaxErrorBehavior 構文エラーの動作 。デフォルトでは例外がスローされます。
- AssemblyOutputKind アセンブリは、ファイル ストリームまたはメモリ ストリームに出力されます。
- OutputFolder アセンブリ出力ディレクトリ、デフォルトは現在の APP の DynamicLibraryFolders ディレクトリです。
- CustomUsingShut は、顧客がカスタマイズした using 参照を使用します。

ランダムなドメインに Test クラスを生成します

```cs
Natasha コンパイル コンポーネントと環境を初期化
NatashaInitializer.Initialize();
// コンパイル単位を作成し、アセンブリ名を指定します
AssemblyCSharpBuilder oop = new AssemblyCSharpBuilder("myAssembly");
//コンパイルユニットは、ドメイン管理から割り当てられたランダムドメインを使用して oop
します。 Domain = DomainManagement.Random;
/追加コードをコンパイル単位に追加
oop. Add(@"namespace HelloWorld{ public class Test{ public Test(){ Name = null; } public string Name; }  }");
// 短い名前に基づいてアセンブリ内のクラスを取得し、長い名前は "HelloWorld.Test" などの
Type type = oop です。 GetTypeFromShortName("Test");
上記の文字列の構築を示し、Natasha は NClass などの操作を簡略化するためのテンプレートを提供し、上記のコードは
var type = NClass に変換
。 RandomDomain()
. Namespace("HelloWorld")
. Name("Test")
. Ctor(item => item. Public(). Body("Name = null;" ))
. PublicField<string>("Name")
. GetType();
```

このアセンブリは、type を使用して、その直後のドメインに属している場合に注意してください。 DisposeDomain() は、GC が参照をアンロードできるように参照を削除します。 メインドメイン(プログラムが開始するドメイン)は共有ドメインとも呼ばれ、ランダムドメインはメインドメインのタイプとデータを取得し、ランダムドメイン間の呼び出しは許可されません。

## 単純なシナリオ

この学習では、Natasha を使用してクラスを構築する方法を学習しましたが、AOP プロキシ クラスの実装など、いくつかの簡単なシナリオを自分で実行しようとすることができます。

以前に書かれた例があり、参照可能です。 Contoller は動的 API 機能のために動的に構築することもできますが、MVC/WebAPI に関する知識が必要です。 また、FreeSql などの CodeFirst 対応 ORM と組み合わせることで、プログラムの初期化時にテーブル構造を作成できます。

Natashaは、実際の動的な実戦プロジェクトであり、上記の例は、必要な場合、ハードカバーを運ばないようにアドバイスする必要があります。

## 計画

この記事では、ナタシャの氷山の一角を明らかにし、次に、より多くの技術とアプリケーションについて説明します。
